# CS-320-Project: Java Unit Tests

To ensure my code, program, or software is functional and secure, I have to define a process for testing it. In this project, I achieved this by using Junit5, a testing framework for Java programs. Using Junit5, I made tests for the project by simply using the annotations and assertions to verify code. But not just any assertion will do. I have to test that any creation of objects and their method calls do not behave unexpectedly. Even if code is tested without error, I need to ensure the code is shown to actually work. In my summary and reflection report, I cited specific examples where I practiced verifying code operations.

Interpreting user needs and specifications becomes very important as details are worked out. The way I start is by taking everything word by word and implementing only what is asked and nothing else, yet. The general idea for the software is created and tested. Once a working version is created, I then go through the details of the specifications and what is implied. For example, when one of the specifications asked to make an in-memory data structure to hold contact objects, I started out with just a variable. Due to the fact that the specification is vague, I decide to research data structures in Java that can take an arbitrary number of objects. I decided that the array list in Java was the most fitting structure, and thus based my tests on that. In the end, the user's clarification on specifications should always be sought after, if possible. 

This is a way I approach software design. Start with clarification, then plan out the code, then create a working version of the software or test. Once a basis is formed, I can then iterate and improve this code little by little. A lot of planning and thought goes into creating software, and testing is one of the last filters for errors. Keeping this testing process in mind while coding helps me create more quality software, and keeping the coding in mind helps me create better tests.
